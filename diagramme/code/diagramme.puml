@startuml
skinparam class {
BackgroundColor AliceBlue
ArrowColor DarkTurquoise
BorderColor Turquoise
}

skinparam stereotypeCBackgroundColor DarkTurquoise
skinparam stereotypeIBackgroundColor Magenta
skinparam stereotypeABackgroundColor Yellow

hide stereotype
hide empty member

package "arbre"{
    package "exceptions"{
        abstract class AnalyseException{
            AnalyseException(String m)
        }

        AnalyseException -up-|> RuntimeException

        class AnalyseLexicaleException{
            AnalyseLexicalException(int ligne, int colonne, String m)
        }
        AnalyseLexicaleException -up-|> AnalyseException

        class AnalyseSyntaxiqueException{
            AnalyseSyntaxiqueException(String m)
        }
        AnalyseSyntaxiqueException -up-|> AnalyseException

        class AnalyseSemantiqueException{
            AnalyseSemantiqueException(String m)
        }
        AnalyseSemantiqueException -up-|> AnalyseException

        class AnalyseLexicaleSemantiqueException{
            AnalyseLexicaleSemantiqueException(String m)
        }
        AnalyseLexicaleSemantiqueException -up-|> AnalyseException

        class VariableNonDeclaree{
            VariableNonDeclaree(String m)
        }
        VariableNonDeclaree -up-|> AnalyseSemantiqueException

        class DoubleDeclaration{
            DoubleDeclaration(String m)
        }
        DoubleDeclaration -up-|> AnalyseSemantiqueException

        class Erreur{
            final String message
            final int ligne
            String getMessage()
            int getLigne()
        }

        class ListeErreurs{
            static final ListeErreurs INSTANCE
            ListeErreurs()
            static ListeErreurs getInstance()
            void ajouter(Erreur e)
            int getNbErreurs()
            Erreur getErreur(int i)
            ArrayList<Erreur> getErreurs()
        }
    }
    ListeErreurs --"*"Erreur


    package "instructions"{
        abstract class ArbreAbstrait {
           int noLigne
           ArbreAbstrait(int n)
           int getNoLigne()
           abstract void verifier()
           abstract String toMIPS()
        }

        class BlocDInstructions {
           BlocDInstructions(int n)
           void ajouter(ArbreAbstrait a)
           void verifier()
           String toMIPS()
           String toString()
        }

        BlocDInstructions -up-|> ArbreAbstrait
        BlocDInstructions -up- "*" ArbreAbstrait

        abstract class Instruction {
            Instruction(int n)
        }

        Instruction -up-|> ArbreAbstrait

        class Ecrire {
           Ecrire(int n)
           void verifier()
           String toMIPS()
        }

        Ecrire  -up-|> Instruction

        class Affectation {
           Affectation(Idf idf, Expression e, int n)
           void verifier()
           String toMIPS()
        }

        class Retourne{
        	final Expression expression

        	}
				Retourne --up-|> Expression
        Affectation  -up-|> Instruction

    }


    package "expressions"{
        abstract class Expression {
           Expression(int n)
           abstract boolean isIdf()
           abstract boolean isBool()
           abstract boolean isFonction()
           abstract String getType()
           abstract String getNom()
        }

        Expression  -up-|> ArbreAbstrait
        Ecrire - "1" Expression

        abstract class Constante {
           String cste
           protected Constante(String texte, int n)
           void verfier()
           String toString()
           boolean isIdf
           String getNom()
        }

        Constante  -up-|> Expression


        class ConstanteEntiere {
           ConstanteEntiere(String texte, int n)
           String toMIPS()
           boolean isBool()
           boolean isFonction()
           String getType()

        }

        class Idf {
                   String nom
                   Symbole symbole
                   Idf(String texte, int n)
                   void verifier()
                   String toMIPS()
                   boolean isIdf()
                   boolean isBool()
                   String getType()
                   String getNom()

                }

        ConstanteEntiere  -up-|> Constante

        class ConstanteBooleenne {
           ConstanteBooleenne(String texte, int n)
           String toMIPS()
           boolean isBool()
           boolean isFonction()
           String getType()
        }

        class AppelFonction{
        	final Idf idf
        	AppelFonction(Idf idf, int n)
        	void verifier()
        	String toMIPS()
        	boolean isIdf()
        	boolean isBool()
        	boolean isFonction()
        	String getType()
        	String getNom()
        }

        ConstanteBooleenne  -up-|> Constante
        Affectation - "1" Expression
        Affectation - "1" Idf
        AppelFonction --up-|> Expression

    }
    package "declarations"{
        class Symbole {
            int deplacement
            String type
            Symbole(int deplacement, String type)
            Symbole(String type)
            Symbole(String type, int noLigne)
            int getDeplacement
            void setDeplacement(int deplacement)
            String getType()
            void setType(String type)

        }

        class TDS{
            static final TDS INSTANCE
            final HashMap<String, Symbole> variables
            static TDS getInstance()
            void ajouter(String idf, Symbole symbole) throws DoubleDeclaration
            Symbole identifier(String nom) throws VariableNonDeclaree
            int getTailleZoneVariable()

        }

        class Entree{
        	final String nom
        	Entree(String nom)
        	String getNom()
        }

        class Fonction{
    			final int noLigne;
    			final String idf;
    			Fonction(ArbreAbstrait arbre, int noLigne, String idf)
    			String toMIPS()
    			void verifier()
    			int getNoLigne()
        }

        class ListeFonctions{
        	int cpt
        	static final ListeFonctions INSTANCE
        	ListeFonctions()
        	ListeFonctions getInstance()
        	ajouter(Fonction f)
        	ArrayList<Fonction> getFonctions()
        	int getCpt()
        	void setCpt(int cpt)
        }


        Fonction --"1" ArbreAbstrait
        Fonction --up-|> Expression
        ListeFonctions --"*" Fonction
}
}
@enduml